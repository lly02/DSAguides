@using System.Runtime.InteropServices.JavaScript
@using DSAguides.Interface.Interface
@using DSAguides.Models.DataStructures.Array
@using DSAguides.Models.DataStructures.Array.Model
@using DSAguides.Models.DataStructures.Array.Operations
@using DSAguides.Models.Shared.Animation
@using DSAguides.Helper

@inject ILogger<Array> _logger

@page "/data-structures/array"

<div id="animation" class="w-100">
    <div id="nodes">
        <div class="row m-0">
            @foreach (var node in _nodes!)
            {
                <div class="col node">@node.ElementToString</div>
            }
        </div>
    </div>
    <div id="information">
        <span class="information-text">Information</span>
    </div>
    <div id="options" class="accordion">
        <div class="accordion-item new">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" data-bs-toggle="collapse" data-bs-target="#new-collapse">
                    New
                </button>
            </h2>
            <div id="new-collapse" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <EditForm Model="@_newArrayModel" OnValidSubmit="@OnNewArray">
                        <DataAnnotationsValidator />

                        <label>
                            Input up to 10 elements of array separated by commas ("int, int, int"):<br />
                            <InputText @bind-Value=_newArrayModel.NewArray />
                            <button type="submit">Run</button>
                            <ValidationMessage For="@(() => _newArrayModel.NewArray)" />
                        </label>
                    </EditForm>
                </div>
            </div>
        </div>
        @*<div class="accordion-item insert">
            <h2 class="accordion-header">
                <button class="accordion-button" data-bs-toggle="collapse" data-bs-target="#add-collapse">
                    Insert
                </button>
            </h2>
            <div id="insert-collapse" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <input @bind=InsertValue/>
                    <button @onclick=OnInsertValue>Run</button>
                </div>
            </div>
        </div>
        <div class="accordion-item remove">
            <h2 class="accordion-header">
                <button class="accordion-button" data-bs-toggle="collapse" data-bs-target="#remove-collapse">
                    Remove
                </button>
            </h2>
            <div id="remove-collapse" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <input @bind="RemoveIndex"/>
                    <button @onclick=OnRemove>Run</button>
                </div>
            </div>
        </div>*@
        <div class="accordion-item clear">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" data-bs-toggle="collapse" data-bs-target="#clear-collapse">
                    Clear
                </button>
            </h2>
            <div id="clear-collapse" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <button @onclick=OnClear>Run</button>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private NewArrayModel _newArrayModel = new();

    //string _newArray = "0";
    //string _insertValue = "0";
    //string _removeIndex = "0";

    //string NewArray
    //{
    //    get => _newArray;
    //    set => _newArray = value;
    //}
    //string InsertValue
    //{
    //    get => _insertValue;
    //    set => _insertValue = value;
    //}
    //string RemoveIndex {
    //    get => _removeIndex;
    //    set => _removeIndex = value;
    //}

    INode[]? _nodes;
    AnimationEnum _animationState = AnimationEnum.Stopped;
    int delay = 500;

    async Task OnNewArray()
    {
        _logger.LogInformation("Running new array");
        if (!StartAnimation()) return;

        int[] intArray = Utility.StringToIntArray(_newArrayModel.NewArray!);
        INode[] result = new ArrayNodeFactory().CreateNodes(intArray);
        _logger.LogInformation("NewArray received: {NewArray}", _newArrayModel.NewArray!);
        ArrayOperation operation = new ArrayNewOperation(_nodes!, result);

        _logger.LogInformation("Animation playing");
        while (_animationState == AnimationEnum.Playing)
        {
            _nodes = operation.NextFrame();

            StateHasChanged();

            _animationState = operation.Done ? AnimationEnum.Stopped : _animationState;

            await Delay();
        }
        _logger.LogInformation("Animation ended");
    }

    //async Task OnInsertValue()
    //{
    //    _logger.LogInformation("Running insert element");
    //    if (!StartAnimation()) return;

    //    INode[] result = Utility.AppendNode(_nodes!, int.Parse(InsertValue));
    //    _logger.LogInformation("Add value received: {AddValue}", InsertValue);
    //    ArrayOperation operation = new ArrayAddOperation(_nodes!, result);

    //    _logger.LogInformation("Animation playing");
    //    while (_animationState == AnimationEnum.Playing)
    //    {
    //        _nodes = operation.NextFrame();

    //        StateHasChanged();

    //        _animationState = operation.Done ? AnimationEnum.Stopped : _animationState;

    //        await Delay();
    //    }
    //    _logger.LogInformation("Animation ended");
    //}

    //async Task OnRemove()
    //{
    //    _logger.LogInformation("Running remove element");
    //    if (!StartAnimation()) return;

    //    INode[] result = Utility.RemoveIndex(_nodes!, int.Parse(RemoveIndex));
    //    _logger.LogInformation("Remove index received: {RemoveIndex}", RemoveIndex);
    //    ArrayOperation operation = new ArrayRemoveOperation(_nodes!, result);

    //    _logger.LogInformation("Animation playing");
    //    while (_animationState == AnimationEnum.Playing)
    //    {
    //        _nodes = operation.NextFrame();

    //        StateHasChanged();

    //        _animationState = operation.Done ? AnimationEnum.Stopped : _animationState;

    //        await Delay();
    //    }
    //    _logger.LogInformation("Animation ended");
    //}

    async Task OnClear()
    {
        _logger.LogInformation("Running clear array");
        if (!StartAnimation()) return;

        INode[] result = new ArrayNodeFactory().CreateNodes(_nodes!.Length);
        ArrayOperation operation = new ArrayClearOperation(_nodes!, result);

        _logger.LogInformation("Animation playing");
        while (_animationState == AnimationEnum.Playing)
        {
            _nodes = operation.NextFrame();

            StateHasChanged();

            _animationState = operation.Done ? AnimationEnum.Stopped : _animationState;

            await Delay();
        }
        _logger.LogInformation("Animation ended");
    }

    bool StartAnimation()
    {
        if (_animationState == AnimationEnum.Playing) return false;
        _animationState = AnimationEnum.Playing;
        return true;
    }

    async Task Delay()
    {
        await Task.Delay(delay);
    }

    protected override async Task OnInitializedAsync()
    {
        _nodes = new ArrayNodeFactory().CreateNodes(10);

        await base.OnInitializedAsync(); 
    }
}